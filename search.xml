<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何自己实现python的字典？]]></title>
    <url>%2F2019%2F12%2F19%2Fpython%E7%9A%84%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[python通过散列表来实现dict类型。理解python如何实现dict的原理之后，我们就可以自己来实现python的字典了,实现之前， 先了解一下相关的基本概念。 基本概念了解 可散列的数据类型 如果一个对象是可以散列的，那么在这个对象的生命周期内，他的散列值是不变的，而且这个对象实现了__hash__方法。可散列 对象还需要实现了__eq__方法，这样才能和其它的对象进行比较。如果两个可散列对象是相等的，那么他们的散列值一定是相等的。 散列表 散列表其实是一个稀疏数组(总是存在空白元素的数组), 散列表里的单元称作为表元。在dict的散列表中每个键值对占用一个表元 每个表元都有两个部分，一个是对键的引用，一个是对值的引用。 散列表的算法 a[key]获取逻辑 计算hash(key)获取 key的散列值 根据散列值获取偏移量 根据偏移量获取散列表的表元 如果表元为空，抛出keyerror异常。 如果表元不为空，判断表元存的key和获取的key是否相等。 如果相等， 返回表元中存的value。 如果不相等，存在冲突。通过特殊方法获取新的偏移量,重复执行第三步直到结束 a[key]=value的逻辑 计算hash(key)获取key的值散列值 根据散列值获取偏移量 根据偏移量获取散列表的表元 － 如果表元的引用为空，将表元的key设置为a[key]的key, 表元的value设置成 value 如果表元不为空，判断表元中的key和a[key]的key是否相等 如果相等，将表元的value设置成新的value 如果不相等，通过特殊方法获取新的偏移量，重复执行第三步直到结束 del a[key]的逻辑类似，不再赘述。 当散列表过于拥挤的时候，python解释器都可能为字典作出扩容的决定。会产生一个更大的散列表，把已有的数据添加进去。 自定义字典的实现 有了上述的了解之后，我们就可以自己实现了python的字典了。具体代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129from typing import Dictclass Node(object): __slots__ = ("key", "value", "status") __status_choices__ = ("Active", "Deleted") def __init__(self, key=None, value=None, status=None): self.key = key self.value = value self.status = status or "Active" def reset(self): self.status = "Deleted" @property def is_active(self): return self.status == "Active" @property def is_deleted(self): return self.status == "Deleted" @is_active.setter def is_active(self, value): if value is True: self.status = "Active" elif value is False: self.status = "Deleted" else: raise Exception("参数错误")class CustomDict(object): nodes_count = 10 used_nodes = 0 def __init__(self, data: Dict = None): self._array = self._init(self.nodes_count) if data: assert isinstance(data, dict) for key, value in data.items(): self[key] = value def _init(self, count): return [Node(status="Deleted") for x in range(count)] def __setitem__(self, key, value): hash_str = key while True: hash_str = str(self.hash(hash_str)) position = int(hash_str[:self.digit]) node = self._array[position] if node.key is None or node.key == key or node.is_deleted: node.key = key node.value = value node.is_active = True self.used_nodes += 1 if self._need_expansion: print('need expansion') self._expansion() break else: print("hash conflict") def __delitem__(self, key): hash_str = key while True: hash_str = str(self.hash(hash_str)) position = int(hash_str[:self.digit]) node = self._array[position] if node.key is None or (node.key == key and node.is_deleted): # node为空 raise KeyError(key) elif node.key == key and node.is_active: # key相等 self.used_nodes -= 1 node.reset() break else: print("hash conflict") def __getitem__(self, item): hash_str = item while True: hash_str = str(self.hash(hash_str)) position = int(hash_str[:self.digit]) node = self._array[position] if node.key is None: # node为空 raise KeyError(item) elif node.key == item and node.is_active: # key相等 return node.value @property def digit(self): return len(str(self.nodes_count // 3)) def hash(self, key): return abs(hash(key)) @property def _need_expansion(self): return self.used_nodes * 2 &gt; self.nodes_count def _expansion(self): self.nodes_count *= 10 self._array, old_array = self._init(self.nodes_count), self._array for node in old_array: if node.is_active: print(node.key, node.value) self[node.key] = node.value def items(self): for node in self._array: if node.is_active: yield node.key, node.value def keys(self): return [x.key for x in self._array if x.is_active] def values(self): return [x.value for x in self._array if x.is_active] def __len__(self): return len(self.keys()) 12345678910111213&gt;&gt;&gt; a = CustomDict()&gt;&gt;&gt; a[&apos;name&apos;] = &quot;ethan&quot;&gt;&gt;&gt; a[&apos;name&apos;]ethan&gt;&gt;&gt; a[111] = 111; a[1111] = 2222&gt;&gt;&gt; print(a[111], a[1111])111 2222&gt;&gt;&gt; a.keys()[&apos;name&apos;, 1111, 111]&gt;&gt;&gt; a.values()[&apos;ethan&apos;, 2222, 111]&gt;&gt;&gt; len(a)3 总结 通过了解python字典的原理，自然而然就能理解字典的一些特点了。 dict为什么是无序的？ 因为dict的key和value作为一个表元存在散列表里面,偏移量并不是根据存入的顺序决定的。所以自然是无序的。 为什么不能在遍历的时候往字典里面添加元素？ 因为在字典里面添加元素的时候，字典随时都可能扩容，导致顺序发生变化。导致遍历变得不可预知。]]></content>
      <tags>
        <tag>dict</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数内省]]></title>
    <url>%2F2019%2F12%2F02%2F%E5%87%BD%E6%95%B0%E5%86%85%E7%9C%81%2F</url>
    <content type="text"></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kubeadm搭建k8s]]></title>
    <url>%2F2019%2F11%2F30%2Fkubeadm%E6%90%AD%E5%BB%BAk8s%2F</url>
    <content type="text"><![CDATA[docker环境准备 docker 版本要&lt;= 18.09,如果版本过高先卸载docker docker 卸载 第一步 1dpkg -l | grep -i docker 第二步(purge 第一步的输出的结果，并不一定是下面的结果) 1sudo apt-get purge -y docker-engine docker docker.io docker-ce docker安装 1234567891011121314151617181920212223242526272829303132333435# Install Docker CE## Set up the repository:### Install packages to allow apt to use a repository over HTTPSapt-get update &amp;&amp; apt-get install apt-transport-https ca-certificates curl software-properties-common### Add Docker’s official GPG keycurl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -### Add Docker apt repository.add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable"## Install Docker CE.apt-get update &amp;&amp; apt-get install docker-ce=18.06.2~ce~3-0~ubuntu# Setup daemon.cat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123; "exec-opts": ["native.cgroupdriver=systemd"], "log-driver": "json-file", "log-opts": &#123; "max-size": "100m" &#125;, "storage-driver": "overlay2"&#125;EOFmkdir -p /etc/systemd/system/docker.service.d# Restart docker.systemctl daemon-reloadsystemctl restart docker linux环境配置 关闭swap, swapoff -a Ensure iptables tooling does not use the nftables backend 1234sudo update-alternatives --set iptables /usr/sbin/iptables-legacysudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacysudo update-alternatives --set arptables /usr/sbin/arptables-legacysudo update-alternatives --set ebtables /usr/sbin/ebtables-legacy k8s安装 #### 安装k8sadm 1234567891011sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curlcurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.listdeb https://apt.kubernetes.io/ kuberne tes-xenial mainEOFsudo apt-get updatesudo apt-get install -y kubelet kubeadm kubectlsudo apt-mark hold kubelet kubeadm kubectlsystemctl daemon-reloadsystemctl restart kubelet kubeadm 安装集群 通过如下命令安装集群 如果在同一个内网可以通过内网地址, 公网ip地址. 如果需要 1kubeadm init --apiserver-advertise-address=YOUR_IP --pod-network-cidr=10.244.0.0/16 安装完有输出一些命令 依次执行命令 保存加入集群的命令 12kubeadm join xx.xx.xx.xxx:6443 --token xxihhlliat3bim8g3a6iv \ --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxx 安装 pod network 1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/2140ac876ef134e0ed5af15c65e414cf26827915/Documentation/kube-flannel.yml node 结点操作 跟上述操作一样安装完k8sadm后，执行保存的加入k8s集群命令就ok了]]></content>
      <tags>
        <tag>linux</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.05.06-2019-11-30]]></title>
    <url>%2F2019%2F11%2F30%2F%E8%BF%91%E4%BA%94%E4%B8%AA%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[嗯，一不小心入职大半年了，写一个小小的总结吧。 阅读方面，这半年来，看了代码大全，活着，我是猫，罗生门，流畅的python, 思考快与慢，敏捷软件开发， head first 设计模式等书籍。确实从这些书中学习和了解了 很多东西，但是目标不是很明确。若求广度，没有明确的主题，书的数量也不够多。若求深度， 我也没有很仔细仔细的研读每一本书。下次需要明确主题，确定书的范围，确定 阅读的方式。 工作方面，这半年融汇了以前的工作经验，搭建了一个flask的框架。对django 也有了更多的认识， 在使用drf的过程中也根据业务写了一些的基类。 基于fabric写了 许多自动更新，部署的代码。 基于mq+mattermost写了一个reminder的小项目。 也写了像kobe, gromit这样提高效率的小脚本。总的来说做得还不错，但是还有一些问题。 文档不够清楚 总结和记录不够 设计和画图能力不够 需要好好思考如何改进。 在生活方面，有按时吃三餐，缺乏运动，经常熬夜，宿舍环境脏乱，零食吃的太多，体重过重。需要很大的改进。 人际关系方面，与同事相处都还不错，很幸运能碰到这样的一群人，只是在帮助rachel留下来这件事上，我还是让自己失望了，我没有做好一个朋友的应该做的。然后她 把我拉黑了，我对她很失望。 感情方面。我开始不习惯我习惯的孤独了，这让我感到无能无力的失落。 六个多月来，大部分时间我没有偏离自己的轨道，我也开始有了一点点信心。]]></content>
      <categories>
        <category>plan</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兰姨]]></title>
    <url>%2F2019%2F09%2F19%2F%E5%85%B0%E5%A7%A8%2F</url>
    <content type="text"><![CDATA[我听说兰姨的男人很会挣钱，一天能有300块钱，在工地上，忍受着严寒酷暑，一天不休干满一个月能挣9000块，可是即使这样干满一个月，又能怎么样呢？ 我听说兰姨的身体很好，即使是在化疗后，白细胞水平也维持的不错，胃口也很好, 说话的声音还很大，还会安慰其它的病友。 我听说兰姨手术后恢复的也不错，一些常见的术后并发症完全没有。 可是，手术后没几个月复查的就查出复发了。没有打预防转移复发的靶向药是一个重大的原因，我听说，兰姨认为没有必要进行吃预防药了，术后多吃点 营养品就好了。 谁不想听医生的话，好好吃饭，按时打针吃药呢？ 我听说兰姨有三个孩子，老大今年高中毕业，老二明年高中毕业，老三后年高中毕业。要是把钱拿去打预防的药，那他们怎么办呢？ 后来，我听说兰姨以泪洗面。 而我除了让这让所有人都感到痛苦的同情，和毫无用处的祝福之外什么都给不了, 我没有改变一切的力量。 愿所有勤劳朴实的人都能被生活温柔以待。]]></content>
  </entry>
  <entry>
    <title><![CDATA[约定]]></title>
    <url>%2F2019%2F09%2F03%2F%E8%BF%9C%E6%96%B9%2F</url>
    <content type="text"><![CDATA[时间真的是杀猪刀，我都不敢相信我们认识已经九年了。在我们同桌的时候，我特佩服你，每次我们比赛做数学题，你总是比我快，准确率也比我高。记得有一次有一个物理题， 我套套书上的公式，完全解不出来，但是你天马行空的思路惊到我了，我就觉得,哇塞,你也太聪明了吧。下晚自习的时候，我一般都会迫不及待地回宿舍，而你会继续待在 教室学习，在你的影响之下，后来我也会待在教室继续自习，再后来分班之后，我就又恢复原样了，如果当时仍然和你在同一个班级的话，我觉得我应该会到一个更好的大学去。 这些年来，我们联系甚少，因为我就是这样的一个人，没有事情从不会主动联系别人的，不过算来，你算是我联系的比较多的一个朋友了。这些天你应该入学了，我是真的很高兴 你能考入心仪的学校。也不知道，现在你是否还如以前一样迷茫，如果是，我希望你能在学校找到真正的方向。我一直很喜欢一句话，朝闻道，夕死可矣，如果能让我明白宇宙的 真理，万事万物的规律，即使让我现在死去，我也愿意。宁愿明明白白的死去，也不要迷茫的渡过一生。 还记得你一考失败，把自己关在家里，不接任何人电话，二战成功之后，告诉我说，如果没有考上怎么好意思联系你呢？其实，你不用在乎别人的看法的，你尽力而为，做好你自己， 即使失败了又能怎么样呢？悠悠苍天,曷此其极，有些时候不是你不够努力，不够聪明，而是有些事情是无法避免的。你考上，我为你高兴，你没有考上，我觉得惋惜，也就这样了。 并不是要你很成功很成功才能成为别人的朋友的,你真正的朋友是不会在乎这些的。 这些年来，我过得一塌糊涂，一事无成，反而搞砸了好多好多事情，在这shit一样的生活面前，我体会到那种无能为力的绝望感。回顾这些年被我浪费的昂贵的时光，我无时无刻不 在后悔，望君引以为戒。 现在你去深圳求学，开启三年的研究生之路，我在长沙上班，迷茫不知前路。我现在有时候会觉得生命由一帧一帧的画面组成，从出生到死亡，所有的足迹，汇聚成人生，一路走来， 过去的已成定格，如果我们现在不做一些有价值的事情，又怎能弥补过去犯下的错，又拿什么来面对将来的自己呢。以前我们比赛做题目，现在我想跟你开始另一个比赛。 未来三年，认准一个方向，竭尽所能，全力以赴，做到自己能做到的一切。 我知道我愚笨，或许以后还是啥也做不好，但是我很想以后能有资格能说一句，我真的尽力了。 所以，这个比赛你愿意来吗？ 这些时间你入学了，我也不知道送你啥，就随便拿个东西给你了，希望你会喜欢吧，也祝你享受新的旅程。]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[encrypt]]></title>
    <url>%2F2019%2F09%2F02%2Fencrypt%2F</url>
    <content type="text"><![CDATA[编辑nginx默认配置 vim /etc/nginx/sites-enabled/default,添加如下配置 1234location ^~ /.well-known/acme-challenge/ &#123; default_type &quot;text/plain&quot;; root /usr/share/nginx/html; &#125; sudo nginx -s reload # 重启nginx 安装certbot sudo apt-get install certbot 申请证书 1sudo certbot certonly --webroot -w /usr/share/nginx/html/ -d share.ismewen.com --register-unsafely-without-email 如上图所示表示建立成功了 nginx 启用https配置 修改nginx的配置,启用https 在/etc/nginx/conf.d 目录下面添加xx.conf如下配置 12345678910111213141516171819202122server &#123; listen 80; server_name share.ismewen.com; return 301 https://$server_name$request_uri;&#125;server &#123; listen 443; server_name share.ismewen.com; ssl on; ssl_certificate /etc/letsencrypt/live/share.ismewen.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/share.ismewen.com/privkey.pem; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; root /home/administrator/work/study/public; location / &#123; index index.html index.htm; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy初篇]]></title>
    <url>%2F2019%2F08%2F21%2Fsqlalchemy%E5%88%9D%E7%AF%87%2F</url>
    <content type="text"><![CDATA[让我掉下眼泪的，不止昨夜的酒 让我依依不舍的，不止妳的温柔 在那座阴雨的小城里 我从未忘记sqlalchemy django用的越多，越觉得sqlalchemy的好用，不想这么好用的工具就此生疏，决定再重新翻阅slqalchemy的文档一遍，于此记些笔记。]]></content>
      <categories>
        <category>sqlalchemy</category>
      </categories>
      <tags>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[powershell基本语法]]></title>
    <url>%2F2019%2F08%2F17%2Fpowershell%2Fpowershell%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[变量 powershell中的变量名都以$开始，powershell变量名大小写不敏感。 1$a=10 # 变量定义，注意和shell 不同 a=10 条件判断 比较运算符 -eq ：等于 -ne ：不等于 -gt ：大于 -ge ：大于等于 -lt ：小于 -le ：小于等于 -contains ：包含 -notcontains :不包含 布尔运算 -and ：和 -or ：或 -xor ：异或 -not ：逆 where-object 过滤 where object 跟python 的列表生成有异曲同工之妙 Some-Command | where-object{SOME_CONDITION} # 返回满足条件的结果 if语句 1234567891011$a=1If($a -eq 1)&#123; Write-Host "if"&#125;Elseif($a -eq 2)&#123; Write-Host "elif"&#125;Else&#123; Write-Host "not meet if" &#125; switch 语句 12345678910$value=99# 使用 Switch 测试取值范围, switch 还支持配配符比较switch($value)&#123; &#123;$_ -lt 5 &#125; &#123; "小于5"; break&#125; &#123;$_ -gt 0 &#125; &#123; "大于0"; break&#125; &#123;$_ -lt 100&#125; &#123; "小于100"; break&#125; 101 &#123;"等于101"&#125; Default &#123;"没有匹配条件"&#125;&#125; 数组 数组创建 数组 （） ，用 “,” 分割 12345$id=1,2,3,4$id=@(1,2,2)$id=@() # 空数组$id=,1 # 等价 $id=@(1)[int[]] $nums=@() # 强类型数组，数组的元素必须都是数字，如果不是数字会报错 数组查询 123456$id=1,2,3,4$id[0] # 国际惯例，从0开始计数$id[0..2] # 选取0到2 都是闭区间 $id[-1] # 获取最后一个元素$id.count # 数组的长度$id[$id.count..0] 数组操作 12345678910$id+='hello'$id=$id+2$id=$id[0..1]+$[3..$id.count] # 你不是真正的删除，本质是重新赋值$id=$id[1..$id.count] # 删除第一个元素$id=$id[0..($id.count-2)] # 删除最后一个元素$str="hello world"$str.Tochararray() # 字符串转数组 $id is [array] # 判断变量是否是数组$id.getType() # 获取变量的类型$back_up = $id.clone() # 赋值数组 hash表 hash表用{}创建用 &quot;;&quot;分割 创建hash表 123$man = @&#123;name="wen";age="10"&#125; # 哈希表用；分割，数组用逗号分割 $man is [array] # false$man.gettype() # hashtable hash表查询 12345678910# 直接 . + key 获取$man.name$man.age# [key] 的形式获取$man["name"]$man["name", "age"] # 有点意思$man.keys # 返回所有的 键$man[$man.keys] # 返回所有的values hash 表的基本操作 12345678$man.girl_friend= "桔梗" # 添加不存在的key的时候，便可以为hash表添加新的元素$man.age = 24 # 对已经存在的key重新复制就是修改$man.clear() # 清空hash表$man.clone() # clone 一个hash表$man.remove(key) # 删除元素$man.contains() # 检测key 是否存在$man.containsKey() # 检测key 是否存在$man.containsValue() # 检测value是否存在 循环 Foreach-object 1234Get-WmiObject Win32_Service | ForEach-Object &#123; if ($_.ProcessId -gt 3000) &#123; "&#123;0&#125;(&#123;1&#125;)" -f $_.DisplayName,$_.ProcessID&#125;&#125; foreach $ids=1,2,2,3,4,45 foreach($id in $ids) { Write-Host $id } do-while 12345$i=100do&#123; Write-Host $i $i=$i-1&#125;while($i -lt 0) 国际惯例: continue: 结束本次循环, 开始下次循环 break: 跳出循环 for 循环 12345678$sum=0$i=1for(;$i -le 100;)&#123; $sum+=$i $i++&#125;$sum 函数 基本定义 12345Function FuncName&#123; Write-Host "hello world" &#125;del Function:FuncName # 删除函数 $args 1FuncName 1 2 3 4 # 函数中$args存储传进来的参数 $args=[1,2,3,4] 带名字的参数 !! 带名字的参数 $args 变量为空 1234567function StringContact($str1="hh",$str2="hh")&#123; Write-Host $str1 $str2 Write-Host $args Write-Host "what happen" return $str1+$str2&#125;StringContact("hello","ethan") 强类型的参数 12345function subtract([int]$value1,[int]$value2)&#123; return $value1-$value2&#125;subtract 2 1 类和对象 python 的类 只能在 5.0及其以上才能使用 对象的创建 12345678910$ethan=New-Object PSObject -Property `@&#123; name="ethan"; age=18; books=@("","","");&#125;Add-Member -InputObject $ethan -MemberType NoteProperty -Name Color -Value "Red" # 添加新的属性Add-Member -in $ethan CopyMethod speak&#123; Write-Host "hello world" &#125; # 添加新的方法（添加带参数的方法的时候会报错） 类定义 12345678910111213141516171819Class Student&#123; [String]$Name; [UInt32]$SID; Student([String]$Name,[UInt32]$SID) &#123; $this.Name=$Name $this.SID=$SID &#125; [String]getSID() &#123; return $this.SID &#125;&#125;$ethan=[Student]::new("ethan",1)$ethan.Name$ethan.SID]]></content>
      <categories>
        <category>powershell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[码乙己]]></title>
    <url>%2F2019%2F08%2F17%2F%E7%A0%81%E4%B9%99%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[鲁镇露天烧烤摊的格局，说来可能也与别处相同: 一个油光发亮的横匾，上书写着鲁镇烧烤摊几个大字；一个露天的院子，里面摆满了圆桌；几个烧烤架，摆在最外面， 烧烤师傅，熟练的翻转，撒着调料，时不时的还拿出扇子，扇一扇，诱惑远处着的行人。 我从十二岁起，每逢假期便来在这烧烤摊当跑腿的，做些端茶送水的工作，到现在七年有余了。这家烧烤摊生意兴隆，愈晚生意愈好，直到两三点才会渐渐冷清下去。往来的主顾， 莫不是三两结群，在此恰烧烤，喝酒，划拳，谈天说地,我有时听的入迷，还忘记了本职工作，为此没少被掌柜的说。但是码乙己不同，他总是一个人来，一个人去。为此 我对他的印象很深刻。 码乙己是来烧烤摊不喝酒,不划拳唯一的人。他身材瘦弱，脸色青黄，头发皱巴巴的，白发丛生，一开始我以为是个三十的中年大叔了，没曾想才二十四岁。码乙己是个码农， 准确的来说，是一个迂腐，附庸风雅的码农。他对人说话，亦是些什么优雅，面向对象，设计，架构之类，让人不懂的话，其中还掺杂些之乎者也，经常惹得其他主顾哈哈 大笑，有时吃东西的时候，他也会拿着一本&lt;&lt;python从入门到放弃&gt;&gt;，在那摇头晃脑。于是乎他就得了一个码乙己的名称。 码乙己经常来烧烤摊，他来的时候一般是凌晨之后了。码乙己一到店，所有喝酒的人便笑话码乙己，有的叫道：“码乙己，你头上的白发又多了”。他不不回答，径直走向我， 对我说，“温两碗酒，要一碟茴香豆”。其他喝酒的人，继续起哄着，高深嚷道： “码乙己，你一定又加班到现在了”。码乙己睁大眼睛说，“你怎么这样凭空污人清白……” “什么清白?我前天亲眼看见你一个人凌晨一点半了背着个双肩包从公司里面出来”。码乙己涨红了脸，争辩着道，&quot;自愿加班不叫加班，况且，程序员的加班能叫加班吗？&quot;接下来 便是什么，“穷且益坚”，“什么者乎”，大家都哄笑起来，院子里充满了快活的气息。 听别人说，码乙己不好好学习，毕业后找不到工作，是一个培训后的码农，水平较低，任务都做不完，于是天天在公司里面加班, 以求不被辞退。 码乙己喝过两杯农药之后，脸色渐渐恢复了。旁人又问码乙己， “码乙己， 你当真会写代码吗？”。码乙己看着问他的人，神气而有力的道，“当然”。他们见码乙己神气的模样自然 又哄笑起来，“我听说程序员薪水都过万，为何你却如此寒酸？”。码乙己听了，顿时泄了气， 无力反驳，自顾自的的吃起花生米来。 码乙己是这样的使人快活，可是没有他，别人也便这么过。 有一天，大约是在九月三十号，碰到一位主顾要温两碗酒，加一碟茴香豆。我才想起了码乙己，这几样一般是他点的，他好像已经长久没有来了。问主柜，好像很久 没有看到码乙己了呢，“码乙己啊，确实很久没看到了呢，现在经济形势不好，你看我们的生意也不好，他呀，约莫着是被裁，离开鲁镇了吧”，一位主顾接话道，“也可能是进icu了吧，毕竟他天天加班来着呢”。 说完，院子里的人都笑了起来。“温两碗酒，要一碟茴香豆”，一个耳熟的声音传来过来，正是码乙己。码乙己头上的白发有多了许多，面容也更加枯槁，眼神里 也没有任何的亮光。 自那天以后，我再也没有见过码乙己。听人说，去长沙了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[shell运算符]]></title>
    <url>%2F2019%2F08%2F17%2Fshell%2Fshell%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[关系运算符 -eq: equal 检测两个数是否相等 , 相等的时候返回True[ $a -eq $b ] -ne: not equal 检测两个数是否不相等，不相等的时候返回True [ $a -nq $b ] -gt: greater than 大于符号 [ $a -get $b ] -ge: greater and equal 大于等于 -lt: less than 小于 -le: less or equal 小于等于 为啥不直接用数学运算符来表示呢？ 算数运算符 原生的bash 并不支持算数运算符，不过 我们有 expr operator_list= +, -, *, /, ==, != expr value_left operator value_right bool 运算 !: 非 o: or 或 a: and 于 字符串运算 =: 是否相等 !=: 是否不等 -z: 长度是否为zero(为空) -n: 长度是否不为zero str: 是否为空 文件测试运算 使用 1[-b $file] -b: 是否为块设备 -c: 是否为字符串设备 -d: 是否为目录 -f: 是否是普通文件（不是目录页不是设备文件） -g: 是否设置了 sgid 位 -r: 是否可读 -w: 是否可写 -x: 是否可执行 -e: exits是否存在]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell-grammar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[powershell环境搭建]]></title>
    <url>%2F2019%2F08%2F16%2Fpowershell%2Fpowershell%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[下载powershell core windows用户可以直接跳过。其它系统可以参考下面链接安装。 参考 installing Powershell Core 下载安装完成之后命令行输入 pwsh 进入powershell的命令行,键入如下命令。 1Write-Host "hello world" 显示结果如下。 pycharm下载powershell插件 new-&gt;powershell script 建立源码文件就能愉快的开始编码了]]></content>
      <categories>
        <category>powershell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux命令]]></title>
    <url>%2F2019%2F08%2F15%2Flinux%2Fcommands%2Flinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux命令比较多，加之本人愚昧健忘，偶尔想起了某个命令，只记得大概做啥用的，学的很零散。到了真正的要用的时候，还得去翻文档，教程。不如在此记录一命令 的常见用法，便于以后查阅。 cat命令 基本功能 显示文件：cat file1 file2 显示一个文件或者多个文件的内容 创建文件: cat &gt; file1 从键盘中将输入的内容写入 file1 # ctl+c结束输入, 清空文件内容 + 写入新的内容 cat &gt;&gt; file 追加 cat &gt; file &lt;&lt; eof xxx eof # 将 xxx 写入file 合并文件： cat file1 fiel2 &gt; file3 基本参数 -n: 输出的时候显示编号 -s: 遇到连续的空行只显示一行 ls命令 基本功能 显示文件和文件目录，默认显示当前目录下的文件和目录 基本参数 -a: 显示所有的文件（.开头的文件为隐藏文件） -c: c 意思为change 而不是 create, 文件的最后修改时间，需要和-l同时使用, 显示文件的最后修改时间 -l: 显示长字符串 -h: human以人类可读的方式显示文件大小 -R: 递归处理 -n: 与-l类似，显示uid 和 gid -m: 平铺显示]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux-command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell入门]]></title>
    <url>%2F2019%2F08%2F15%2Fshell%2Fshell%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一直喜欢terminal,很多命令和shell编写都不懂，着实有些汗颜，于是决定好好学习linux和shell编程。 变量定义和使用 12a= "wen" # 要注意空格，a = "wen" 是错的$a # 获取当前变量的值 数组 数组的基本操作 12345678a=(1,2, 3,4)$&#123;#a[@]&#125; # 获取数组的长度$&#123;#a[*]&#125; # 获取数组的长度$&#123;a[*]&#125; # 查看数组的所有元素$&#123;a[@]&#125; # 查看数组的所有元素$&#123;a[0]&#125; # 获取第一个元素unset a[2] # 删除第三个元素 数组的遍历 123456789101112# 索引遍历a=(1 2 3 4)for((i=0;i&lt;$&#123;#a[*]&#125;;i++))do echo $&#123;a[$i]&#125;done# for in 遍历for i in $&#123;a[*]&#125;do echo $&#123;i&#125;done 关联数组 12345678declare -A dict # 使用之前必须要先声明为一个关联数组dict=([name]='ethan' [age]=18)for i in $&#123;!dict[*]&#125;do echo $i "---" $&#123;dict[$i]&#125; done 12345$&#123;!dict[*]&#125;: # 相当于dict.keys() ,获取数组的所有的key值$&#123;!dict[@]&#125;: #j相当于dict.keys() ,获取数组的所有的key值$&#123;dict[*]&#125;: # 相当于dict.values(), 获取数组所有的value$&#123;dict[@]&#125;: # 相当于dict.values(), 获取数组所有的value$&#123;#dict[@]&#125;: # 获取数组的长度 函数 shell中的函数没有参数的概念，通过 $1,$2, 超过10个用 ${n}获取 12345678910# way 1function some &#123; echo "hello world"&#125;# way 2some() &#123; echo "hello world"&#125;some 1 2 3 4 5 # 函数调用, 1 2 3 4 5 将作为函数的参数，在函数内部可以通过$1 $2 $3 获取 分支语句 if 基本句型 12345678if commands; then commandselif commands; then commandselse commandsfi case 基本句型 1234567891011case $1 in ld) echo "welcome ld" ;; thief) echo "get out!" ;; *) echo "defautl action" ;;esac 循环基本句型 break可强行退出循环，break语句仅能退出当前的循环，如果是两层循环嵌套，则需要在外层循环中使用break。 continue 跳出本次循环 for 循环 123456789101112# python 风格 （好吧，bash实际上在前, python 用的多，所以这样 称呼)for var in listdo commandsdone# 类 c 风格for((number= 1; number&lt;= 5; number++))do echo "$number"done while 和 until 只是退出的条件不同，仅仅是为了嗯 while 循环 1234while command # if command True then run else exitdo commanddone]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell-grammar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fsm]]></title>
    <url>%2F2019%2F06%2F30%2Ffsm%2F</url>
    <content type="text"><![CDATA[fsm(finite-state machine，缩写：FSM）又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。一直比 较喜欢使用状态机来撸业务。而且看了下新公司的代码，各种状态定义，迁移，感觉也比较适合用状态机。便开始搜索第三方的的fsm库。发现了了两个库 django-fsm和transitions。 便打算选一个加入到项目中去。 django-fsm 之前一直用 大神基于transitions写的sqlalchemy model的状态机，看django-fsm的文档的时候，发现django-fsm没有一些钩子函数，不符合个人使用习惯， 于是稍微改了一下，加入before, 和 after两个钩子函数， 同时通过变量配置状态机。代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from django.db import modelsfrom django.db.models.base import ModelBasefrom django_fsm import transition, FSMFieldclass Transition(object): def __init__(self, field, trigger, source, target, before=None, after=None, on_error=None, conditions=None, permission=None, custom=None): self.field = field self.trigger = trigger self.source = source self.target = target if isinstance(before, list): self.before = before elif isinstance(before, str): self.before = [before] elif before is None: self.before = [] else: raise TypeError("before param must be str or list") if isinstance(after, list): self.after = after elif isinstance(after, str): self.after = [after] if after else [] elif after is None: self.after = [] else: raise TypeError("after param must be str or list") self.on_error = on_error if on_error else [] self.conditions = conditions if conditions else [] self.permission = permission self.custom = custom if custom else dict() def as_django_fsm_dict(self): attrs = ["source", "target", "on_error", "conditions", "permission", "custom"] return &#123;field: getattr(self, field) for field in attrs&#125;class FSMMetaClass(ModelBase): def __new__(mcs, name, bases, attrs, **kwargs): new_class = ModelBase.__new__(mcs, name, bases, attrs, **kwargs) states = attrs.get("__states__", None) transitions = attrs.get("__transitions__", None) transitions = transitions or [] field = getattr(new_class, 'status').field for t in transitions: tran = Transition(field=field, **t) assert tran.target in states, '%s not in __states__' % tran.target assert tran.source in states, '%s not in __states__' % tran.source def trigger(self, **kwargs): pass trigger.__name__ = tran.trigger trigger_func = transition(field=field, **tran.as_django_fsm_dict())(trigger) setattr(new_class, tran.trigger, trigger_func) for callback in tran.after: assert hasattr(new_class, callback), "%s has attribute %s" % (new_class.__name__, callback) assert callable(getattr(new_class, callback)), "%s must be a method" % callback setattr(trigger_func, "_after_callbacks", tran.after) for callback in tran.before: assert hasattr(new_class, callback), "%s has attribute %s" % (new_class.__name__, callback) assert callable(getattr(new_class, callback)), "%s must be a method" % callback setattr(trigger_func, "_before_callbacks", tran.before) return new_class class FSMModel(models.Model, metaclass=FSMMetaClass): __abstract__ = True __states__ = None __transitions__ = None status = FSMField(default='solid') class Meta: abstract = True 信号注册 1234567891011121314151617181920212223242526272829303132from django_fsm import pre_transition, post_transitiondef pre_transition_connect(*args, **kwargs): import ipdb ipdb.set_trace() trigger_name = kwargs.get("name") instance = kwargs.get("instance") trigger_func = getattr(instance, trigger_name) before_callbacks = getattr(trigger_func, "_before_callbacks") for pre_callback_name in before_callbacks: pre_callback = getattr(instance, pre_callback_name) pre_callback(*kwargs.get("method_args"), **kwargs.get("method_kwargs"))pre_transition.connect(pre_transition_connect)def post_transition_connect(*args, **kwargs): import ipdb ipdb.set_trace() trigger_name = kwargs.get("name") instance = kwargs.get("instance") trigger_func = getattr(instance, trigger_name) after_callbacks = getattr(trigger_func, "_after_callbacks") for post_callback_name in after_callbacks: post_callback = getattr(instance, post_callback_name) post_callback(*kwargs.get("method_args"), **kwargs.get("method_kwargs"))post_transition.connect(post_transition_connect) 思路如下 通过metaclass,根据__transitions__这个变量动态为model添加transitions。 在trigger中引入两个_after_callbacks，和 _before_callbacks 两个变量，django-fsm的信号触发在这个变量中的函数 django model with transitions 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165from typing import Listfrom django.core.exceptions import ObjectDoesNotExistfrom django.db import modelsfrom django.db.models.fields.related_descriptors import ReverseOneToOneDescriptorfrom transitions.extensions import HierarchicalMachine as Machine# Create your models here.class StateMachineModel(models.Model): __states__ = ( ('initial', "Initial"), ) __transitions__ = [] # transitions __state_children_mapping__ = dict() # state name, rel __initial_state__ = 'pending' # init state status = models.CharField(max_length=32, verbose_name="Status", default='initial', choices=__states__) class Meta: abstract = True @property def state(self): return self.status @state.setter def state(self, value): self.status = value def __init__(self, *args, **kwargs): super(StateMachineModel, self).__init__(*args, **kwargs) machine = Machine(model=self, states=self._get_init_states(), transitions=self._get_init_transitions(), initial=self.get_initial_state()) for s, rel in self.__state_children_mapping__.items(): machine.on_enter(s, lambda *args, **kwargs: self._init_obj_for_state(rel=rel)) setattr(self, 'fsm', machine) setattr(self, "fsm", machine) def _innit_obj_for_state(self): pass def get_initial_state(self): if self.status not in self._get_states(): return self.__initial_state__ return self.status @classmethod def get_states(cls) -&gt; List: return list(dict(cls.__states__).keys())[:] @classmethod def _get_states(cls): states = cls.get_states() for state, rel_name in cls.__state_children_mapping__.items(): _descriptor = getattr(cls, rel_name) assert isinstance(_descriptor, ReverseOneToOneDescriptor), '%s must be onetoone field' % rel_name child_model = _descriptor.related.field.model for child_state in child_model.get_states(): states.append("%s_%s" % (state, child_state)) return states def _get_init_states(self): states = self.get_states() _cls = type(self) for state, rel_name in self.__state_children_mapping__.items(): states.remove(state) try: obj = getattr(self, rel_name) except ObjectDoesNotExist as e: relation = getattr(_cls, rel_name) assert isinstance(relation, ReverseOneToOneDescriptor), '%s must be onetoone field' % rel_name remote_model = relation.related.field.model assert issubclass(remote_model, StateMachineModel), "%s must be an StateMachineModel" % remote_model.__name__ obj = remote_model() setattr(obj, _cls.__name__, self) state_dict = &#123;"name": state, "children": obj.fsm&#125; states.append(state_dict) return states def _get_init_transitions(self): return self.__transitions__class Client(StateMachineModel): __states__ = ( ("pending", "Pending"), ("active", "Active"), ("good", "Good"), ("fraud", "Fraud"), ("deleted", "deleted"), ) __transitions__ = [ &#123; "trigger": "activate", "source": "pending", "dest": "active", &#125;, &#123; "trigger": "mark_as_good", "source": "active", "dest": "good", &#125;, &#123; "trigger": "mark_as_fraud", "source": "active", "dest": "fraud", &#125;, &#123; "trigger": "delete_state", "source": "*", "dest": "deleted" &#125;, &#123; "trigger": "do_nothing", "source": "pending", "dest": "pending" &#125; ] __state_children_mapping__ = &#123; "good": 'client_ask_for_leave_sub_flow' &#125; def after_activate(self, *args, **kwargs): print("a huge improvement! We have another customer") def after_fraud(self, *args, **kwargs): print("suspend app!!!")class ClientAskForLeaveSubFlow(StateMachineModel): user = models.OneToOneField(Client, related_name="client_ask_for_leave_sub_flow", on_delete=models.CASCADE) __states__ = ( ('initial', "Initial"), ("processing", "Processing"), ("success", "Success"), ("failed", "Failed"), ) __transitions__ = [ &#123; "trigger": "ask_for_leave", "source": "initial", "dest": "processing", &#125;, &#123; "trigger": "approve", "source": "processing", "dest": "success", &#125;, &#123; "trigger": "reject", "source": "processing", "dest": "failed", &#125;, ] sqlalchemy model with transitions 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172from sqlalchemy.orm.attributes import InstrumentedAttributefrom aggregation import dbfrom transitions.extensions import HierarchicalMachine as Machineclass StateMachineModel(db.Model): __abstract__ = True __states__ = [] __transitions__ = [] __state_children_mapping__ = &#123;&#125; status = db.Column(db.SmallInteger, index=True, default=0, nullable=False) @property def state(self): return self.status @state.setter def state(self, value): self.status = value def __init__(self,*args, **kwargs): super(StateMachineModel, self).__init__(*args,**kwargs) initial = self._get_initial() machine = Machine(model=self, states=self._get_states(), transitions=self.get_transitions(), auto_transitions=False, initial=initial, send_event=True) self.fsm = machine def get_states(self): return self.__states__[:] def _get_initial(self): if self.status is None: self.status = 0 initial = dict(self.get_states()).get(self.status) if initial in self.__state_children_mapping__: rel_obj = getattr(self, self.__state_children_mapping__[initial]) initial = '%s_%s' % (initial, rel_obj.state) return initial def _get_states(self): states_dict = dict(self.get_states()) for key, value in self.__state_children_mapping__.items(): child_obj = getattr(self, value) state_key = dict((y, x) for (x, y) in self.get_states())[key] if child_obj: # 当子状态机已存在, 整合子状态机状态 states_dict[state_key] = &#123; 'name': key, 'children': child_obj.fsm, &#125; else: # 当子状态机不存在，生成一个空对象，表示初始状态 child_relation = getattr(self.__class__, value) assert isinstance(child_relation, InstrumentedAttribute) target_class = child_relation.prop.mapper.class_ assert issubclass(target_class, StateMachineModel) states_dict[state_key] = &#123; 'name': key, 'children': target_class().fsm, &#125; print(states_dict) states = states_dict.values() return list(states) @classmethod def get_transitions(cls): return cls.__transitions__[:] def _init_obj_for_state(self, rel): if not getattr(self, rel, None): class_ = getattr(self.__class__, rel).prop.mapper.class_ obj = class_() db.session.add(obj) setattr(self, rel, obj)class StateMachineClient(StateMachineModel): id = db.Column(db.Integer, primary_key=True) __states__ = ( (0, "initial"), (1000, "pending"), (1001, "active"), (1002, "good"), (1003, "fraud"), (1004, "deleted"), ) __transitions__ = [ &#123; "trigger": "initialize", "source": "initial", "dest": "pending", &#125;, &#123; "trigger": "activate", "source": "pending", "dest": "active", &#125;, &#123; "trigger": "mark_as_good", "source": "active", "dest": "good", &#125;, &#123; "trigger": "mark_as_fraud", "source": "active", "dest": "fraud", &#125;, &#123; "trigger": "delete_state", "source": "*", "dest": "deleted" &#125;, &#123; "trigger": "do_nothing", "source": "pending", "dest": "pending" &#125; ] __state_children_mapping__ = &#123; "good": 'client_ask_for_leave_sub_flow' &#125; def after_activate(self, *args, **kwargs): print("a huge improvement! We have another customer") def after_fraud(self, *args, **kwargs): print("suspend app!!!")class ClientAskForLeaveSubFlow(StateMachineModel): id = db.Column(db.Integer, primary_key=True) client_id = db.Column(db.Integer, db.ForeignKey('state_machine_client.id'), unique=True) user = db.relationship(StateMachineClient, backref=db.backref("client_ask_for_leave_sub_flow", uselist=False)) __states__ = ( (0, "initial"), (1001, "processing"), (1002, "success"), (1003, "failed"), ) __transitions__ = [ &#123; "trigger": "ask_for_leave", "source": "initial", "dest": "processing", &#125;, &#123; "trigger": "approve", "source": "processing", "dest": "success", &#125;, &#123; "trigger": "reject", "source": "processing", "dest": "failed", &#125;, ]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>sqlalchemy</tag>
        <tag>fsm</tag>
        <tag>django</tag>
        <tag>python-metaclass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见问题]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[vimplus 安装后提示 ycm 启动失败 12cd ~/.vim/bundle/YouComepleteMe/usr/bin/python install.py pycurl 安装 1pip install pycurl==7.43.0.1 --global-option=build_ext --global-option="-L/usr/local/opt/openssl/lib" --global-option="-I/usr/local/opt/openssl/include"]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>problems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FAQ]]></title>
    <url>%2F2019%2F05%2F08%2Fproblems%2FFAQ%2F</url>
    <content type="text"><![CDATA[vimplus 安装后提示 ycm 启动失败 12cd ~/.vim/bundle/YouComepleteMe/usr/bin/python install.py pycurl 安装 1pip install pycurl==7.43.0.1 --global-option=build_ext --global-option="-L/usr/local/opt/openssl/lib" --global-option="-I/usr/local/opt/openssl/include"]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>problems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac网络问题]]></title>
    <url>%2F2019%2F05%2F08%2Fproblems%2Fmac%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我一开始也不知道做了什么事情，电脑不能上网了，在windows系统上和mac系统上都是如此，经过测试发现，如果我使用全局代理就能上网。 于是在windows系统下下载了一个360断网急救箱，急救一下就可以了。到了mac系统下，就没有了360断网急救箱了，我google了好久 没有找到类似360断网急救箱的软件。有根据网上的教程还原了网络的配置（也不知道有没有真正的还原成初始配置），清除了dns缓存， 结果还是不能上网，打开网络控制面板，最后发现dns的服务器是192.168.0.1。更改dns服务器成114.114.114.114就解决了这个问题。]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>problems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客]]></title>
    <url>%2F2019%2F05%2F06%2Findex%2F</url>
    <content type="text"><![CDATA[记录一些学习的笔记和思考。 高山仰止,景行行止,虽不能至,然心向往之。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy虚拟model示例]]></title>
    <url>%2F2019%2F04%2F18%2Fsqlalchemy%2Fsqlalchemy%E8%99%9A%E6%8B%9Fmodel%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[虚拟model 虚拟的model就是跟数据的库的视图一样，并不是真正的表，而是通过express构造出来的的model在数据中没有与之对应的表。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class User(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(32)) describe = db.Column(db.String(255))class Tags(db.Model): id = db.Column(db.Integer, primary_key=True) tag = db.Column(db.String(32)) user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True) user = db.relationship(User, backref=db.backref('tags'))class UserProfile(db.Model): id = db.Column(db.Integer, primary_key=True) user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True) user = db.relationship( 'User', lazy=False, backref=db.backref('profile', uselist=False, cascade='all, delete-orphan'), ) email = db.Column(db.String(32)) phone = db.Column(db.Integer)class UserView(db.Model): __custom_table__ = User.__table__.join( UserProfile, UserProfile.user_id == User.id ).join( Tags, Tags.user_id == User.id ) __table__ = db.select([ __custom_table__.c.user_id.label("pk"), __custom_table__.c.user_name.label("name"), __custom_table__.c.user_profile_phone.label("phone"), __custom_table__.c.user_profile_email.label("email"), db.func.count(__custom_table__.c.tags_id).label('tags_count') ]).select_from( __custom_table__ ).group_by( __custom_table__.c.user_id, __custom_table__.c.user_name, __custom_table__.c.user_profile_phone, __custom_table__.c.user_profile_email ).alias("user_view") __mapper_args__ = &#123; 'primary_key': [__table__.c.pk] &#125; shell里面看下效果 1234567In [6]: query = UserView.queryIn [7]: print(render_statement(query))SELECT user_view.pk, user_view.name, user_view.phone, user_view.email, user_view.tags_countFROM (SELECT user.id AS pk, user.name AS name, user_profile.phone AS phone, user_profile.email AS email, count(tags.id) AS tags_countFROM user JOIN user_profile ON user_profile.user_id = user.id JOIN tags ON tags.user_id = user.id GROUP BY user.id, user.name, user_profile.phone, user_profile.email) AS user_view; 虚拟model封装了一层子查询。不仅如此，还能为虚拟model添加relationship，有些时候能够为查询带来很大的便利,提高代码的可阅读性。]]></content>
      <categories>
        <category>python</category>
        <category>sqlalchemy</category>
      </categories>
      <tags>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy通用外键示例]]></title>
    <url>%2F2019%2F04%2F17%2Fsqlalchemy%2Fsqlalchemy%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%96%E9%94%AE%2F</url>
    <content type="text"><![CDATA[通用外键 通用外键并不是一个显示定义的外键字段，而是通过逻辑确定关联的外键。 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445app = Flask(__name__)app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db'db = SQLAlchemy(app)class Remark(db.Model): id = db.Column(db.Integer, primary_key=True) object_id = db.Column(db.Integer) object_table = db.Column(db.String(32)) remark = db.String(db.String(255))class RemarkEnable(object): def add_remark(self, remark: str): remark = Remark(remark=remark, object_id=self.id, object_table=self.__tablename__) self.remark = remark@event.listens_for(RemarkEnable, "mapper_configured", propagate=True)def setup_listener(mapper, class_): object_table = class_.__tablename__ remote = Remark.id class_.remark = db.relationship( Remark, primaryjoin=db.and_( class_.id == db.foreign(db.remote(remote)), Remark.object_table == object_table ), cascade='all,delete', uselist=False, backref=db.backref( 'obj_%s' % object_table, primaryjoin=db.remote(class_.id) == db.foreign(remote), uselist=False ) )class Article(RemarkEnable, db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(32))class Book(RemarkEnable, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(32)) 在shell中看下效果 1234567891011121314151617181920212223In [2]: Book.query.first() In [3]: book = Book(name="人间失格") In [4]: book Out[4]: &lt;Book (transient 4418095424)&gt;In [5]: book.add_remark("this is a book") In [6]: db.session.add(book) In [7]: db.session.commit() In [8]: book Out[8]: &lt;Book 1&gt;In [9]: book.remark Out[9]: &lt;Remark 1&gt;In [10]: Remark.obj_article, Remark.obj_book Out[10]: (&lt;sqlalchemy.orm.attributes.InstrumentedAttribute at 0x107179f10&gt;, &lt;sqlalchemy.orm.attributes.InstrumentedAttribute at 0x1071a5150&gt;) 对于remark表来说，它没有显示定义外键和book， article表关联，而是通过object_id, object_table进行逻辑上的关联。 ### 实现原理 设置一个RemarkEnable的mixin,监听这个RemarkEnable,mapper_configured的事件，为这个类的所有子类(每一个子类都会触发监听事件)添加了一个remark的relation_ship。]]></content>
      <categories>
        <category>python</category>
        <category>sqlalchemy</category>
      </categories>
      <tags>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间失格]]></title>
    <url>%2F2019%2F04%2F16%2Freading%2F%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[那些共情能力弱的人，是很自私光明地在幸福着。我会读这本书，大概是被这句话吸引了。 然而事实证明，我也是个共情能力弱的人，我不理解不了书中的主角叶藏，也认同不了别人对他的评价。 我们认识的小叶个性率真，幽默风趣。只要不喝酒，不，就算喝了酒,…也是个神一样的好孩子。 人间失了格，叶藏同学对人类充满了恐惧，于是酒，烟，娼妓是暂时消除恐惧的绝妙方法。当然叶藏同学，也喜欢非法的集会（共产主义读书会），他喜欢这种非法的感觉， 可能这也是消除恐惧的一种方法。 叶藏同学最喜欢的人是牢狱里面诈骗犯的一个妻子，叫做恒子。恒子的疲惫和穷酸，散发出来的寂寞气息深深的吸引了叶藏，睡了一夜之后然后他就离开了， 叶藏想着趁着还没有受伤，赶快离开。可是他真的能懂恒子的想法吗？让叶藏同学耿耿于怀的事情是，在酒吧结账的时候，是恒子付的全款。叶藏没有钱了，于是他和他的一个朋友来到了恒子当 服务员的酒吧。“请给我酒，我没有钱”，叶藏低声对恒子说到。说到底，所谓的不受伤，还是抵不过一杯酒。叶藏同学终于意识到自己没钱了，下定决心和恒子跳海自杀了。 当恒子死了，而他被救回来之后。竟然连自杀的力气都丧失了。 祝子是叶藏同学的妻子。叶藏同学要取祝子的理由也很简单。迄今为止，我还未和年轻的处女上过床。只要经历一场放纵的快乐，便无怨无悔了。长得帅就是好，想娶谁就娶谁。 毕竟女人可能都是视觉动物吧，因为除了这个，我也想不起祝子喜欢叶藏的任何一个理由了。 叶藏同学染上了毒瘾，为了得到吗啡，开始画春宫图，和药店残疾的老板娘发生了肮脏的关系。最后的最后他回家疗养了，他的家人为他摆平了一切，他回乡下治疗了，期间被一个 被请来照顾他，年纪六旬的女佣残忍侵犯三年。再后来的事情，谁也不知道了。 故事也结束了。我想起了本书的开头。 我这一生尽是可耻之事。]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活着]]></title>
    <url>%2F2019%2F04%2F16%2Freading%2F%E6%B4%BB%E7%9D%80%2F</url>
    <content type="text"><![CDATA[这本书的大部分时间是在午休的时间看的，我以一种错误的方式打开了此书，以至于我在看完之后，久久不能释怀， 这也可能是我看书的一贯原则，我总相信， 书中的人物，无论经历了多少的磨难，多少挫折，在最后的最后，他总是会从这些磨难中获取到力量，然后获得了重生，电视剧难道不是都这么演的吗？ 对我来说，这是故事，对主角来说，这是生活，对大多数人来说，这是历史。我也一直都都相信一切一切都会慢慢好起来的。故事开场了，福贵是地主家的儿子， 嚣张跋扈，吃喝嫖赌样样精通，我想这样的人早晚会栽跟头。果然，在最后一次赌局中，福贵老婆家珍，怀着七个月的身孕跪下来求福贵回家了，福贵同学， 扇了家珍一耳光，把她撵回去了。我想这个人渣，死了也不过分吧？在这个晚上，富贵输掉了一切，没多久富贵父亲也死了，家珍也回娘家了。福贵成了贫农开始 下地干粗活了。我想着家珍肯定会回来的，然后他们一家人勤勤恳恳的生活，这样子也和绝大多数普通人一样，也挺好的吧。家珍回来了，还带回来了一个儿子， 名为有庆。他们一家人也的的确确的勤恳的生活了，可是后来，大环境使然加上厄运的垂青，他们一家人陆续死去。最后死去的是他的孙子，在这之前，我还想着， 福贵他爷孙两相依为命，也算是有一点希望吧，可是到最后只剩下福贵跟一头年迈的老牛。 阅读过程中，我始终带有一种希望，我想一切一切到最后都会好起来的，然而到了最后，我也没有看到。普通人的选择努力，在历史的洪荒之下是那么的苍凉,无力。]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[岛上书店]]></title>
    <url>%2F2019%2F04%2F14%2Freading%2F%E5%B2%9B%E4%B8%8A%E4%B9%A6%E5%BA%97%2F</url>
    <content type="text"><![CDATA[没有谁是一座孤岛，每本书都是一个世界。可万一我是呢？我觉得aj肯定是一座孤岛，他尖酸，刻薄，独自守着破旧的小书店。任由自己的心逐渐荒凉。但 是我能理解他，因为他应该拥有幸福的生活的，他有着一位与他灵魂契合的妻子，他们一起经营着这家书店，与自己喜欢的人，且以自己的爱好为生，还有比这更美好的 事情吗？显然，生活就是个婊子，意外夺走了他妻子的生命，也夺走了他的希望,从此他的心守着这家书店，成了一座荒岛，谁能指责他呢？。 如果没有意外的话，aj将自成一座孤岛，慢慢的枯萎。两岁的弃婴摩雅就是那个意外，她的出现重新燃起了aj的希望，让他重拾爱与接收被爱的权利，也改变了aj 身边的一些其它的人，书店最后转手了，书店的故事在最后也还在继续。 只是，不是谁都能碰到摩雅。]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy之hybrid_property]]></title>
    <url>%2F2019%2F04%2F04%2Fsqlalchemy%2Fsqlalchemy%E4%B9%8Bhybrid-property%2F</url>
    <content type="text"><![CDATA[hybrid 刚刚接触sqlachemy的hybird，浮现在脑海的时候吸血中的hybrid ，狼人和吸血鬼的混血，同时拥有狼人和吸血鬼的超能。在sqlalchemy中，hybrid 也有着相似的意思。 “hybrid” means the attribute has distinct behaviors defined at the class level and at the instance level. 大概的意思是 hybrid意味着属性在实例级别（instance）和类级别（class ）有着不同的表现形式。其实如果了解Pytho的描述符，很容易猜到hybrid的实现方式。 1234567def __get__(self, instance, owner): if instance: # 实例层面 print("i am at the instance level") else: # class 层面 print("i am at the class level") hybrid 基础用法 新建一个 model 12345678910111213141516171819202122232425262728293031from flask import Flask from flask.ctx import AppContextfrom flask_sqlalchemy import SQLAlchemyfrom sqlalchemy.ext.hybrid import hybrid_property, hybrid_methodfrom sqlalchemy_utils import render_statementapp = Flask(__name__)app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db'db = SQLAlchemy(app)# 暴力添加app上下文ctx = AppContext(app)ctx.push()def print_query(query): print(render_statement(query)) class Interval(db.Model): __tablename__ = 'interval' id = db.Column(db.Integer, primary_key=True) start = db.Column(db.Integer, nullable=False) end = db.Column(db.Integer, nullable=False) @hybrid_property def length(self): return self.end - self.start @hybrid_method def contains(self, point): return (self.start &lt;= point) &amp; (point &lt;= self.end) length就是一个hybrid_property了，它看起来好像就和虚拟的column一样。在ipython shell里面先简单体验一番。 123456789101112131415161718192021222324252627282930In [2]: new = Interval(start=1,end=3) In [3]: db.session.add(new) In [4]: db.session.commit() In [5]: new Out[5]: &lt;Interval 2&gt;In [6]: query = Interval.query.filter(Interval.length &gt; 3) In [7]: print_query(query) SELECT interval.id, interval.start, interval.&quot;end&quot; FROM interval WHERE interval.&quot;end&quot; - interval.start &gt; 3;In [8]: Interval.length Out[8]: &lt;sqlalchemy.orm.attributes.create_proxied_attribute.&lt;locals&gt;.Proxy at 0x1049510f8&gt;In [9]: new.length Out[9]: 2In [10]: query = Interval.query.filter(Interval.length &gt; 3).order_by(Interval.length.desc()) In [11]: print_query(query) SELECT interval.id, interval.start, interval.&quot;end&quot; FROM interval WHERE interval.&quot;end&quot; - interval.start &gt; 3 ORDER BY interval.&quot;end&quot; - interval.start DESC; hybrid expression 简单体验了一番，是不是觉得好厉害，直呼 &quot;hybrid_property是在是太好用了，我要在所有的地方都使用hybrid_property,妈妈再也不用担心我写不出复杂的sql语句了。&quot; 然而事情并没有这样简单,比如说下面的这个hybrid_property。 12345@hybrid_propertydef complex_property(self): if self.start &gt; 0: return self.end / self.start return 0 再次进入到shell里面查下一下，看下结果会怎样 1234567In [3]: query = Interval.query.filter(Interval.complex_property &gt; 1) In [4]: print_query(query) SELECT interval.id, interval.start, interval."end" FROM interval WHERE interval."end" / interval.start &gt; 1; 你就会发现，sql语句中没有if的判断了。由此可见hybrid_property不是万能的，你不能指望在hybrid_property里面写一堆复杂python逻辑，然后指望着 orm自动帮你完成一切的操作.这显然是不可能的。但是对于对于复杂一点的逻辑，我们也可以通过expression手动构建生成的sql,如下所示。 12345678910@hybrid_propertydef complex_property(self): if self.start != 0: return self.end / self.start return 0@complex_property.expressiondef complex_property(self): # 返回一个sql expression 用来构建sql return self.end / db.func.nullif(self.start, 0) 总的来说，hybrid_property,能在一定程度上封装业务的复杂性，提高程序的可读性，但也不是万能的，真正万能的是掌握sql的语法。 hybrid method hybrid method 大同小异，看下例子就好了. 1234567In [2]: query = Interval.query.filter(Interval.contains(2)) In [3]: print_query(query) SELECT interval.id, interval.start, interval.&quot;end&quot; FROM interval WHERE interval.start &lt;= 2 AND interval.&quot;end&quot; &gt;= 2; hybrid Comparator 基本用法 hybrid Comparator 允许自定义定义 operation 的时候的 construction。 hybrid_property.comparator() 不能和hybrid_property.expression同时使用。 定义一个例子看一下. 123456789101112131415161718192021222324252627class TestComprator(Comparator): def __clause_element__(self): clause_element = super(TestComprator, self).__clause_element__() # TestUser.name return clause_element def operate(self, op, other): element = self.__clause_element__() return op(db.func.lower(element), db.func.lower(other))class TestGroup(db.Model): id = db.Column(db.Integer, primary_key=True)class TestUser(db.Model): id = db.Column(db.Integer, primary_key=True) group_id = db.Column(db.ForeignKey('test_group.id')) name = db.Column(db.String(32)) @hybrid_property def test_name(self): return self.name.lower() @test_name.comparator def test_name(self): return TestComprator(self.name) 主要看这行代码。op(db.func.lower(element), db.func.lower(other))，在这里不今改变了element，也就是构建的时候传进来的TestUser.name。还改变了 other,也就是拿来比较的对象。也就是下面的 “IIII”。通过定制comprator在比较的时候不仅能修改 element，还能修改other，实现了高度的定制化。 1234567In [2]: query = TestUser.query.filter(TestUser.test_name=="IIII") In [3]: print_query(query) SELECT test_user.id, test_user.group_id, test_user.name FROM test_user WHERE lower(test_user.name) = lower('IIII'); Building Transformers mark一下，以后需要的时候在仔细去看 https://docs.sqlalchemy.org/en/latest/orm/extensions/hybrid.html#building-transformers 其他的property index_property 1234567class Person(db.Model): __tablename__ = 'person' id = db.Column(db.Integer, primary_key=True) data = db.Column(db.JSON) name = index_property('data', 'name') 使用方法 1234567891011121314151617181920In [8]: res Out[8]: &lt;Person 1&gt;In [9]: res.data Out[9]: &#123;'name': 'wen'&#125;In [10]: res.name Out[10]: 'wen'In [11]: res.name = "jian" In [12]: res.data Out[12]: &#123;'name': 'jian'&#125;In [19]: query = Person.query.with_entities(Person.name,Person.id) In [20]: print_query(query) SELECT JSON_QUOTE(JSON_EXTRACT(person.data, '$."name"')) AS fget, person.id FROM person; column_property 12345678910111213141516171819class TestUser(db.Model): id = db.Column(db.Integer, primary_key=True) group_id = db.Column(db.ForeignKey('test_group.id')) name = db.Column(db.String(32))class TestGroup(db.Model): id = db.Column(db.Integer, primary_key=True) user_counts = column_property( db.select( [ db.func.count() ] ).select_from( TestUser ).where( TestUser.group_id == id ) ) 12345678In [7]: query = TestGroup.query In [8]: print_query(query) SELECT (SELECT count(*) AS count_1 FROM test_user WHERE test_user.group_id = test_group.id) AS anon_1, test_group.id FROM test_group; 总结 sql的文档其实介绍的非常详细，但是对粗看之下，又很难理解，一是因为英文的水平，二是，需要浏览大部分文档之后，才能对其中的部分内容有更深的理解。以前没有觉得， 工作以后才发现英文水平是在是太重要了，尤其是对于python来说，第一手资料都是英文的，有了较强的英文阅读能力才能更好理解，掌握前沿的知识，也能理解国外一些大神的见解什么的。]]></content>
      <categories>
        <category>python</category>
        <category>sqlalchemy</category>
      </categories>
      <tags>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask context]]></title>
    <url>%2F2019%2F04%2F02%2Fflask%2Fflask-context%2F</url>
    <content type="text"><![CDATA[app context . 当前激活程序的程序实例，可以通过current_app获得，要注意的是，在非web tuntime的时候需要手动激活程序上下文 1234567from flask import Flask, current_appapp = Flask(__name__)with app.app_context(): # within this block, current_app points to app. print(current_app.name) assert current_app.name==app.name app context 的作用 . 避免显示的到处传递app . 多应用的支持，一个application 中存在多个 flask app context的生命周期 123The application context is created and destroyed as necessary. When a Flask application begins handling a request, it pushes an application context and a request context. When the request ends it pops the request context then the application context. Typically, an application context will have the same lifetime as a request.大概意思是app context 根据需要创建和销毁。当app开始处理一个请求的时候，会压入一个app context 和 request context,请求处理结束的时候，弹出app context和request context那么问题来了？app context 和 requst context 压入到哪里去了呢？这个等下再讲。 app context 多应用代码示例 1234567891011121314151617181920212223242526272829app = Flask('debug')app2 = Flask("nested debug")@app.route('/say_hello')def debug_say_hello(): return 'dubug app say hello to you'@app2.route('/say_hello')def neseted_say_hello(): return 'nested app say hello to you'# print("before enter debug env", current_app) 没有app上下文的时候不能使用current_appwith app.app_context(): print("after enter debug env", current_app) print("======== ======") print("before enter nested debug env", current_app) with app2.app_context(): print("after enter nested debug env", current_app)mounts = &#123; "/nested_debug": app2&#125;m = DispatcherMiddleware(app, mounts=mounts)run_simple('localhost', 5000, m) 浏览器访问以下，结果如下图所示，成功建立了多应用环境 request context 在收到客户端请求的时候，会生成一个请求对象，该对象封装了一些请求信息。如果没有请求上下文，view 函数想要访问请求对象，只能当做参数传进 到视图函数。在多线程服务器中，多个线程会同时处理多个请求，每个线程看到的请求对象都不同。flask使用上下文 让 request 指向请求对象，且在这个线程 内 全局访问，这样就避免了到处显示传递参数了。意思就是，虽然不同的线程会存在不同的请求对象，但是对线程来说， request 指向的是当前线程正在处理的 请求对象，在当前请求的任何地方都能访问修改它，不会影响到其他的线程。 some hook 有时候处理请求的时候，我们需要在请求处理开始，处理结束时的时候 做某些事情，可以通过requst hook完成。 四种基本的 hook . before_first_request 注册一个函数，在处理第一个请求之前执行 . before_request 注册一个函数，在每次请求之前执行 . after_request 注册一个函数，如果没有未处理异常，在每次请求之后执行 . teardown_request 注册一个函数, 即使存在未处理的异常，也会在每次请求之后执行 针对某次请求的 hook, after_this_request 为当前请求注册一个函数，当前请求结束后，执行 代码示例 12345678910111213141516171819202122232425262728293031@app.before_first_requestdef app_before_first_request(): print("app before frist request")@app.before_requestdef app_before_request(): print('app before request')@app.after_requestdef app_after_request(response): print('hi, app after request') return Response("hi, app after request")@app.teardown_requestdef app_teardown_request(exc): print('app teardown request') return Response('hi, app teardown request')@app.route('/')def index(): @after_this_request def after_current_request(response): print("hi, after current request") return Response('hi, after current request') return 'this is index page' 访问index页面的print 如下 123456789101112### first requestapp before frist requestapp before requesthi, after current requesthi, app after requestapp teardown request### second requestapp before requesthi, after current requesthi, app after requestapp teardown request request context 的实现原理 主要是通过Werkzeug库中local模块实现 1from werkzeug import local local类的介绍 看下local的源码将会有更深的认识。这里简单介绍一下local类 回答之前的 app context 和 request context 压入到哪里去了呢？ local类用来存储线程的私有变量. 123456789101112131415161718192021class Local(object): __slots__ = ("__storage__", "__ident_func__") def __init__(self): object.__setattr__(self, "__storage__", &#123;&#125;) object.__setattr__(self, "__ident_func__", get_ident) ... def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; Local类有两个属性__storage__ 和 ident_func 关于 ident_func 12since each thread has its own greenlet we can just use those as identifiers for the context. If greenlets are notavailable we fall back to the current thread ident depending on where it is. 总之 __ident__func 当前运行环境的唯一标示。 ident_func 就像是一把钥匙。__storage__是各个房间，程序在运行的时候，都会获得一把钥匙。 往房间里面存东西，拿东西。都会经历两个如下两个步骤 . 拿着钥匙，进入自己的房间。 . 在自己的房间 存东西，取东西 收到一个请求的时候，flask就在你的房间里面建立了一个 名叫 request 的柜子。我们每次引用request变量的时候。都不是直接访问这个柜子，都会经过两个步骤。 第一步，根据钥匙找到自己的房间。第二步，根据 “request” 这个名字 找到request 的柜子。如果同时收到非常多非常多的请求的时候，每一个request都会不同。 因为他们的钥匙不同，他们进入到的房间就会不同，访问到的柜子也不同。这样便实现了 request 协程或线程间的全局访问和修改。 多 app 原理 上文说过app 指向的都是当前的app，这又是什么呢？ 1234567def _find_app(): top = _app_ctx_stack.top if top is None: raise RuntimeError(_app_ctx_err_msg) return top.appcurrent_app = LocalProxy(_find_app) 123456current_app 指向的都是 _app_ctx_stack 的栈顶。with app1.context(): # app1被压入栈顶, current_app 指向 app1 with app2.context(): # app2 被压入栈顶，current app 指向app2 # 退出app2 context, app2从栈弹出，current_app 又指向app1 other 理解了local模块，才会更深入的理解flask的context。平时还是得多看源码，吸取别人设计，实现的经验，这点我还做的远远不够。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python作用域]]></title>
    <url>%2F2019%2F03%2F10%2Fpython%2Fpython%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[问题背景 python的书籍看不不少，看到作用域的时候都没怎么仔细去看，因为觉得自己已经足够了解了，作用域嘛，简单的很，无非就是，出现一个变量，先看当前作用域里面有木有，木有，有就用当前作用域里面的，木有就去上层作用域去找，直到找到了为止，嘿嘿，虽然就明白了这一点点东西，但是好像在大部分情况下还用的好好的，直到之前写了一个装饰器，遇到了一个百思不得其解的问题，才让我好好审视了一下python的作用域，所以记录一下以加深对python作用域的理解。 问题是这样子的 1234567891011121314151617181920def class_retry_fetch(times, errors=(Exception,), delay=None): def deco(func): # def wrapper(self, *args, **kwargs): is_error = True retry_times = times while retry_times &gt; 0 and is_error: try: ret = func(self, *args, **kwargs) return ret except errors as e: retry_times -= 1 if retry_times == 0: raise e if delay and isinstance(delay, int): time.sleep(delay) return None return wrapper return deco 同事写了上面一个装饰器,后来新开了一个项目的时候，我复制了这个装饰器，然后觉得times 这个命名不好，于是决定把times改成retry_times,于是我把times 改成了retry_times,再把下面的retry_times=times改去掉了。就变成了下面这个样子。 12345678910111213141516171819def class_retry_fetch(retry_times, errors=(Exception,), delay=None): def deco(func): # def wrapper(self, *args, **kwargs): is_error = True while retry_times &gt; 0 and is_error: try: ret = func(self, *args, **kwargs) return ret except errors as e: retry_times -= 1 if retry_times == 0: raise e if delay and isinstance(delay, int): time.sleep(delay) return None return wrapper return deco 然后pycharm就提示我unresolved reference ‘retry_times’,我就惊呆了，按照我的理解，最外层上面不是有一个retry_times吗，怎么会找不到了呢？不会是萌萌哒pycharm出问题了吧，于是乎我跑了一下测试用例，结果发现，原来是真的！不是pycharm的问题，是真的找不到retry_times了。和我之前理解的不一样，后来问了一下同事，了解到了global, nonlocal等关键词，仔细查阅了一些资料才明白其中的原理。unresolved reference 'retry_times’这个问题之所以会出现是因为在wrapper函数中 出现了retry_times -= 1，又对retry_times进行赋值操作，retry_times被认为是局部作用域里面。所以而retry_times在wraper函数中未申明过，所以就报错了。要解决这个问题很简单。1，第一种就是把retry_times 在wrapper函数中赋值给另外一个变量other_var，然后修改other_var的值，这样就不会报错了。第二种只能在python3中使用，通过nonlocal关键词进行申明。如下所示。 1234567891011121314151617181920def class_retry_fetch(retry_times, errors=(Exception,), delay=None): def deco(func): # def wrapper(self, *args, **kwargs): is_error = True nonlocal retry_times while retry_times &gt; 0 and is_error: try: ret = func(self, *args, **kwargs) return ret except errors as e: retry_times -= 1 if retry_times == 0: raise e if delay and isinstance(delay, int): time.sleep(delay) return None return wrapper return deco LEGB 看了上面的例子，肯定是一脸懵逼的。但是如果理解了LEGB也就完全理解了，上述错误产生的原因，以及怎样改才正确的了。LEGB指的是作用域的查找顺序即，Local-&gt;Enclosing-&gt;Global-&gt;Builtin . local: 函数范围内的变量（不完全准确） . nonlocal: 外部嵌套函数中的变量 . global: 模块级别的变量 . built: 内置的变量例如， map,filter, sum等等 还是从例子中去理解LEGB规则。 123456789101112name = "this" # @1assert "name" in globals()assert "name" in locals()def some_test(): name = "is" # @2 assert "name" in globals() assert "name" in locals() def hello_world(): assert "name" in globals() assert "name" in locals() name = "my" # @3print(name) 对于@1处的name来说，它属于模块级别的变量,能在globals()中直接找找到。 对于@2处的name来说， 它定义在函数内部，会产生一个局部作用域，它的查找顺序就是 当前的局部作用域Local @2处的name-&gt; 全局作用域Global @1出的name 对于@3出的name来说，它也定义在函数内部，也会产生一个局部作用域，它的查找顺序就是 当前的局部作用域local @3出的name-&gt;enclosing域中的@2处name-&gt;全局作用域中的@1处的name。 如果在hello_world中想使用enclosing域中的@2处name，在python2则必须定义一个局部变量 ，把name赋值给这个局部变量，如此便能修改了。在python3中可以使用 nonlocal 关键字申明name,在hello_world中就可以直接使用了。 一些面试题详解 上面是LEGB的基本介绍了，但是感觉说的还是不清不楚的😂,还是通过一些面试题来说具体说明吧。 面试题一 1234name = "wen"def some_test(): name += "test"some_test() # 输出是什么？ 没有输出，因为会抛出UnboundLocalError的错误，在some_test函数的作用域中出现了name的申明，name += “test” &lt;&lt;==&gt;&gt; name = name + “test”,而locals()中没有name变量，所以抛出异常。如果要在local作用域中使用global中的变量，可以通过Global关键字，修改如下 12345678name = "wen"def some_test(): assert "name" not in locals() # False assert "name" in globals() # True global name # 使用global中的name 即some test下的name绑定到了global中， assert "name" not in locals() # False name += "test"some_test() # output: wentest 面试题二 1234567name = "lzl"def f1(): print(name)def f2(): name = "eric" f1()f2() # output: lzl name=“lzl”与f1()在一个作用域链，和代码的定义位置有关系，跟执行位置没有关系。所以name使用的是global中的变量 面试题三 12li = [lambda :x for x in range(2)]print(li[0]()) # output: 2 黄哥Python回答： 由于编程语言延迟求值的特性，在使用延迟求值的时候，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值，当调用li0 函数时，x的值已经是9了，所以输出的是9 命名空间补充 参考 . Python命名空间和作用域窥探 . python 作用域与名称空间? . Python 五个知识点搞定作用域]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python-scope</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python装饰器]]></title>
    <url>%2F2018%2F11%2F25%2Fpython%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[什么是装饰器？ 装饰器(Decorators)是python的一种咋看起来很难理解的，但其实很容易的语法。它的本质其实是一个函数或者类，可以在不改变原函数的情况下添加新的功能。写个简单例子理解它的实现。 123# v1def hello_world(): print("hello world") 某一天我收到了老板新的需求，写了上面的一个hello_world的函数，老板悄悄告诉我说，可以先让项目运行的卡一点，后续作为优化可以多收服务费。我一听，啧啧称奇，不愧是boss,果然是深谋远虑，于是乎我就重写了一下如下。 1234# v2def hello_world(): time.sleep(5000) print("hello world") 果然后续老板成功收到了优化的服务费用，老板尝到甜头之后，在新的项目开始后，开始指着代码对我说，这里，这里，这里让它先睡个一两秒，毕竟跑这么累，服务器也需要休息的，老板果真是好人，连服务器的辛苦都放在心里，怕它累着了，我感动不已，临码涕零,所谓林禽择木而栖，往后余生，愿鞍前马后，肝脑涂地，以效犬马之劳。一番苦想之后，终于实现了，代码如下。 12345678# v3def compassionate_boss(func): def decorator(): time.sleep(5000) func() return decoratorhello_world = compassionate_boss(hello_world) 如此这般，只要把需要休息的函数hello_world当做参数传入compassionate_boss函数将其返回值再赋值给需要休息的函数的函数名即可。新的hello_world 现在是compassionate_boss(hello_world)的返回值了，也就是decorator函数，那当我们执行hello_world的时候，实际上执行的是decorator(),也就是time.sleep()和func()这两行代码，那func是啥呢？显然就是传入得参数了，也就是原来的hello_world函数了，新的hello_world相比于以前的hello_word也就多了一个休息的功能,其它需要休息的函数如法炮制一下就可以了。由于我出色了完成了任务，老板午饭多点了一个鸡腿，嗯，有点香。 上述的compassionate_boss函数也就是一个装饰器函数了，通过它在没有改动原函数任何代码的基础上成功的添加了休息的功能，不过这个写法怎么和我们平时看到的装饰器不一样呢，好像这些函数都带了有一个**@符号的帽子，这里啥都没有，怎么就跑出来呢一个装饰器了呢？@呢，是python的语法糖，戴帽子的函数呢是需要装饰的函数，@**后面的函数呢，也就装饰器函数了。那这顶帽子为我们做了什么事情呢，其实也就是为我们执行了这样hello_world = compassionate_boss(hello_world)一个赋值操作。详细写法如下。 123456789def compassionate_boss(func): def decorator(): time.sleep(5000) func() return decorator@compassionate_boss # &lt;==&gt; hello_world = compassionate_boss(hello_world)def hello_world(): print("hello world") 带参数的装饰器 后来，boss把我骂了一顿，说我设置的休息时间太短了，一点都不会体恤服务器的辛苦，boss要亲自上马设置时间，此时此刻，就需要带参数的装饰器出马了。其具体写法如下,compassionate_boss(sleep_time=5)返回的就是wraper函数，实际上就是用wraper函数在装饰hello_world函数，但是通过函数的闭包巧妙的传了一个参数到decorator中去了。 123456789101112def compassionate_boss(sleep_time): def wraper(func): def decorator(): time.sleep(sleep_time) func() return decorator return wraper@compassionate_boss(sleep_time=5)def hello_world(): print("hello world") 后来boss亲自上阵设了10s的休息时间,boss就是boss，是个狼人，比狠人还多一点，佩服佩服。 类装饰器 boss喜爱读书，最近他在读面向对象方面的书籍，老在我面前说什么依赖注入，控制反转，什么上层不应该依赖于细节，应该依赖于抽象，抽象不应该依赖细节，细节应该依赖于抽象，看到了我的装饰器之后说，你看你这个装饰器，一点都不oop，你要用类去实现它。我:…。好吧，你是boss,你说了算。 123456789101112131415161718class CompassionateBoss(): def __init__(self, time_sleep): self.time_sleep = time_sleep def __call__(self, func): time.sleep(self.time_sleep) def wraper(): time.sleep(self.time_sleep) func() return wraper()@CompassionateBoss(time_sleep=5)def test(): print "test" 装饰器的问题 在上述的例子中我们得到了一个新的hello_world函数，但是我们也说过这个hello_world指向的是一个闭包函数，原函数的元信息不见了，那怎么办呢，为了保持原函数的元信息，之后把原函数的信息复制过来了，唉，真累，这么麻烦。不过还好，我们有functools.wraps，它会帮我们复制这些信息。 12345678910def compassionate_boss(sleep_time): @wraps(func) def wraper(func): def decorator(): time.sleep(sleep_time) func() return decorator return wraper 总结 装饰器的核心原理是函数闭包，[维基](https://zh.wikipedia.org/wiki/闭包_(计算机科学)上如是说:在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作上值(upvalue)。只要理解@的作用本质上就是做了hello_world = compassionate_boss(hello_world)这样的一个操作，装饰器的写法什么的也就可推导出来了。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>decorator</tag>
      </tags>
  </entry>
</search>
